"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _isInteger() {
  var data = _interopRequireDefault(require("lodash/isInteger"));

  _isInteger = function _isInteger() {
    return data;
  };

  return data;
}

function _repeat() {
  var data = _interopRequireDefault(require("lodash/repeat"));

  _repeat = function _repeat() {
    return data;
  };

  return data;
}

var _buffer = _interopRequireDefault(require("./buffer"));

var n = _interopRequireWildcard(require("./node"));

function t() {
  var data = _interopRequireWildcard(require("@babel/types"));

  t = function t() {
    return data;
  };

  return data;
}

var generatorFunctions = _interopRequireWildcard(require("./generators"));

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};if (desc.get || desc.set) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
    }newObj.default = obj;return newObj;
  }
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var SCIENTIFIC_NOTATION = /e/i;
var ZERO_DECIMAL_INTEGER = /\.0+$/;
var NON_DECIMAL_LITERAL = /^0[box]/;

var Printer = function () {
  function Printer(format, map) {
    _classCallCheck(this, Printer);

    this.inForStatementInitCounter = 0;
    this._printStack = [];
    this._indent = 0;
    this._insideAux = false;
    this._printedCommentStarts = {};
    this._parenPushNewlineState = null;
    this._noLineTerminator = false;
    this._printAuxAfterOnNextUserNode = false;
    this._printedComments = new WeakSet();
    this._endsWithInteger = false;
    this._endsWithWord = false;
    this.format = format || {};
    this._buf = new _buffer.default(map);
  }

  _createClass(Printer, [{
    key: "generate",
    value: function generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    }
  }, {
    key: "indent",
    value: function indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    }
  }, {
    key: "dedent",
    value: function dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    }
  }, {
    key: "semicolon",
    value: function semicolon() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      this._maybeAddAuxComment();

      this._append(";", !force);
    }
  }, {
    key: "rightBrace",
    value: function rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    }
  }, {
    key: "space",
    value: function space() {
      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    }
  }, {
    key: "word",
    value: function word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    }
  }, {
    key: "number",
    value: function number(str) {
      this.word(str);
      this._endsWithInteger = (0, _isInteger().default)(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    }
  }, {
    key: "token",
    value: function token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    }
  }, {
    key: "newline",
    value: function newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (var j = 0; j < i; j++) {
        this._newline();
      }
    }
  }, {
    key: "endsWith",
    value: function endsWith(str) {
      return this._buf.endsWith(str);
    }
  }, {
    key: "removeTrailingNewline",
    value: function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    }
  }, {
    key: "exactSource",
    value: function exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    }
  }, {
    key: "source",
    value: function source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    }
  }, {
    key: "withSource",
    value: function withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    }
  }, {
    key: "_space",
    value: function _space() {
      this._append(" ", true);
    }
  }, {
    key: "_newline",
    value: function _newline() {
      this._append("\n", true);
    }
  }, {
    key: "_append",
    value: function _append(str) {
      var queue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    }
  }, {
    key: "_maybeIndent",
    value: function _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    }
  }, {
    key: "_maybeAddParen",
    value: function _maybeAddParen(str) {
      var parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      this._parenPushNewlineState = null;
      var i = void 0;

      for (i = 0; i < str.length && str[i] === " "; i++) {
        continue;
      }if (i === str.length) return;
      var cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/") return;
        if (i + 1 === str.length) return;
        var chaPost = str[i + 1];
        if (chaPost !== "/" && chaPost !== "*") return;
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    }
  }, {
    key: "_catchUp",
    value: function _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      var pos = loc ? loc[prop] : null;

      if (pos && pos.line !== null) {
        var count = pos.line - this._buf.getCurrentLine();

        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    }
  }, {
    key: "_getIndent",
    value: function _getIndent() {
      return (0, _repeat().default)(this.format.indent.style, this._indent);
    }
  }, {
    key: "startTerminatorless",
    value: function startTerminatorless() {
      var isLabel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    }
  }, {
    key: "endTerminatorless",
    value: function endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state && state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    }
  }, {
    key: "print",
    value: function print(node, parent) {
      var _this = this;

      if (!node) return;
      var oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      var printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node && node.constructor.name));
      }

      this._printStack.push(node);

      var oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      var needsParens = n.needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens = true;
      }

      if (needsParens) this.token("(");

      this._printLeadingComments(node);

      var loc = t().isProgram(node) || t().isFile(node) ? null : node.loc;
      this.withSource("start", loc, function () {
        printMethod.call(_this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    }
  }, {
    key: "_maybeAddAuxComment",
    value: function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    }
  }, {
    key: "_printAuxBeforeComment",
    value: function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }
  }, {
    key: "_printAuxAfterComment",
    value: function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    }
  }, {
    key: "getPossibleRaw",
    value: function getPossibleRaw(node) {
      var extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    }
  }, {
    key: "printJoin",
    value: function printJoin(nodes, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!nodes || !nodes.length) return;
      if (opts.indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    }
  }, {
    key: "printAndIndentOnComments",
    value: function printAndIndentOnComments(node, parent) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    }
  }, {
    key: "printBlock",
    value: function printBlock(parent) {
      var node = parent.body;

      if (!t().isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    }
  }, {
    key: "_printTrailingComments",
    value: function _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    }
  }, {
    key: "_printLeadingComments",
    value: function _printLeadingComments(node) {
      this._printComments(this._getComments(true, node));
    }
  }, {
    key: "printInnerComments",
    value: function printInnerComments(node) {
      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (!node.innerComments || !node.innerComments.length) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    }
  }, {
    key: "printSequence",
    value: function printSequence(nodes, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    }
  }, {
    key: "printList",
    value: function printList(items, parent) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    }
  }, {
    key: "_printNewline",
    value: function _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      var lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        var needs = leading ? n.needsWhitespaceBefore : n.needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    }
  }, {
    key: "_getComments",
    value: function _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    }
  }, {
    key: "_printComment",
    value: function _printComment(comment) {
      var _this2 = this;

      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      if (comment.start != null) {
        if (this._printedCommentStarts[comment.start]) return;
        this._printedCommentStarts[comment.start] = true;
      }

      var isBlockComment = comment.type === "CommentBlock";
      this.newline(this._buf.hasContent() && !this._noLineTerminator && isBlockComment ? 1 : 0);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var offset = comment.loc && comment.loc.start.column;

        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indentSize = Math.max(this._getIndent().length, this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n" + (0, _repeat().default)(" ", indentSize));
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, function () {
        _this2._append(val);
      });
      this.newline(isBlockComment && !this._noLineTerminator ? 1 : 0);
    }
  }, {
    key: "_printComments",
    value: function _printComments(comments) {
      if (!comments || !comments.length) return;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = comments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var comment = _step.value;

          this._printComment(comment);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);

  return Printer;
}();

exports.default = Printer;
Object.assign(Printer.prototype, generatorFunctions);

function commaSeparator() {
  this.token(",");
  this.space();
}
//# sourceMappingURL=printer.js.map