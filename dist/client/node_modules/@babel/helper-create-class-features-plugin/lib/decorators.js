"use strict";

var _templateObject = _taggedTemplateLiteral(["return ", ""], ["return ", ""]),
    _templateObject2 = _taggedTemplateLiteral(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "], ["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "]),
    _templateObject3 = _taggedTemplateLiteral(["let ", " = ", ""], ["let ", " = ", ""]),
    _templateObject4 = _taggedTemplateLiteral(["", "(this)"], ["", "(this)"]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasOwnDecorators = hasOwnDecorators;
exports.hasDecorators = hasDecorators;
exports.buildDecoratedClass = buildDecoratedClass;

function _core() {
  var data = require("@babel/core");

  _core = function _core() {
    return data;
  };

  return data;
}

function _helperReplaceSupers() {
  var data = _interopRequireDefault(require("@babel/helper-replace-supers"));

  _helperReplaceSupers = function _helperReplaceSupers() {
    return data;
  };

  return data;
}

function _helperFunctionName() {
  var data = _interopRequireDefault(require("@babel/helper-function-name"));

  _helperFunctionName = function _helperFunctionName() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function hasOwnDecorators(node) {
  return !!(node.decorators && node.decorators.length);
}

function hasDecorators(node) {
  return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
}

function prop(key, value) {
  if (!value) return null;
  return _core().types.objectProperty(_core().types.identifier(key), value);
}

function method(key, body) {
  return _core().types.objectMethod("method", _core().types.identifier(key), [], _core().types.blockStatement(body));
}

function takeDecorators(node) {
  var result = void 0;

  if (node.decorators && node.decorators.length > 0) {
    result = _core().types.arrayExpression(node.decorators.map(function (decorator) {
      return decorator.expression;
    }));
  }

  node.decorators = undefined;
  return result;
}

function getKey(node) {
  if (node.computed) {
    return node.key;
  } else if (_core().types.isIdentifier(node.key)) {
    return _core().types.stringLiteral(node.key.name);
  } else {
    return _core().types.stringLiteral(String(node.key.value));
  }
}

function extractElementDescriptor(classRef, superRef, path) {
  var node = path.node,
      scope = path.scope;

  var isMethod = path.isClassMethod();

  if (path.isPrivate()) {
    throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
  }

  new (_helperReplaceSupers().default)({
    methodPath: path,
    methodNode: node,
    objectRef: classRef,
    isStatic: node.static,
    superRef: superRef,
    scope: scope,
    file: this
  }, true).replace();
  var properties = [prop("kind", _core().types.stringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node.static && _core().types.booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);

  if (isMethod) {
    var id = node.computed ? null : node.key;

    _core().types.toExpression(node);

    properties.push(prop("value", (0, _helperFunctionName().default)({
      node: node,
      id: id,
      scope: scope
    }) || node));
  } else if (node.value) {
    properties.push(method("value", _core().template.statements.ast(_templateObject, node.value)));
  } else {
    properties.push(prop("value", scope.buildUndefinedNode()));
  }

  path.remove();
  return _core().types.objectExpression(properties);
}

function addDecorateHelper(file) {
  try {
    return file.addHelper("decorate");
  } catch (err) {
    if (err.code === "BABEL_HELPER_UNKNOWN") {
      err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
    }

    throw err;
  }
}

function buildDecoratedClass(ref, path, elements, file) {
  var node = path.node,
      scope = path.scope;

  var initializeId = scope.generateUidIdentifier("initialize");
  var isDeclaration = node.id && path.isDeclaration();
  var isStrict = path.isInStrictMode();
  var superClass = node.superClass;

  node.type = "ClassDeclaration";
  if (!node.id) node.id = _core().types.cloneNode(ref);
  var superId = void 0;

  if (superClass) {
    superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
    node.superClass = superId;
  }

  var classDecorators = takeDecorators(node);

  var definitions = _core().types.arrayExpression(elements.map(extractElementDescriptor.bind(file, node.id, superId)));

  var replacement = _core().template.expression.ast(_templateObject2, addDecorateHelper(file), classDecorators || _core().types.nullLiteral(), initializeId, superClass ? superId : null, node, _core().types.cloneNode(node.id), definitions, superClass);
  var classPathDesc = "arguments.1.body.body.0";

  if (!isStrict) {
    replacement.arguments[1].body.directives.push(_core().types.directive(_core().types.directiveLiteral("use strict")));
  }

  if (isDeclaration) {
    replacement = _core().template.ast(_templateObject3, ref, replacement);
    classPathDesc = "declarations.0.init." + classPathDesc;
  }

  return {
    instanceNodes: [_core().template.statement.ast(_templateObject4, initializeId)],

    wrapClass: function wrapClass(path) {
      path.replaceWith(replacement);
      return path.get(classPathDesc);
    }
  };
}
//# sourceMappingURL=decorators.js.map