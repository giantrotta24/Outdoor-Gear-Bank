"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = loadPrivatePartialConfig;
exports.loadPartialConfig = loadPartialConfig;

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

var _plugin = _interopRequireDefault(require("./plugin"));

var _util = require("./util");

var _item = require("./item");

var _configChain = require("./config-chain");

var _environment = require("./helpers/environment");

var _options = require("./validation/options");

var _files = require("./files");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

function resolveRootMode(rootDir, rootMode) {
  switch (rootMode) {
    case "root":
      return rootDir;

    case "upward-optional":
      {
        var upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
        return upwardRootDir === null ? rootDir : upwardRootDir;
      }

    case "upward":
      {
        var _upwardRootDir = (0, _files.findConfigUpwards)(rootDir);
        if (_upwardRootDir !== null) return _upwardRootDir;
        throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\"")), {
          code: "BABEL_ROOT_NOT_FOUND",
          dirname: rootDir
        });
      }

    default:
      throw new Error("Assertion failure - unknown rootMode value");
  }
}

function loadPrivatePartialConfig(inputOpts) {
  if (inputOpts != null && ((typeof inputOpts === "undefined" ? "undefined" : _typeof(inputOpts)) !== "object" || Array.isArray(inputOpts))) {
    throw new Error("Babel options must be an object, null, or undefined");
  }

  var args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
  var _args$envName = args.envName,
      envName = _args$envName === undefined ? (0, _environment.getEnv)() : _args$envName,
      _args$cwd = args.cwd,
      cwd = _args$cwd === undefined ? "." : _args$cwd,
      _args$root = args.root,
      rootDir = _args$root === undefined ? "." : _args$root,
      _args$rootMode = args.rootMode,
      rootMode = _args$rootMode === undefined ? "root" : _args$rootMode,
      caller = args.caller;


  var absoluteCwd = _path().default.resolve(cwd);

  var absoluteRootDir = resolveRootMode(_path().default.resolve(absoluteCwd, rootDir), rootMode);
  var context = {
    filename: typeof args.filename === "string" ? _path().default.resolve(cwd, args.filename) : undefined,
    cwd: absoluteCwd,
    root: absoluteRootDir,
    envName: envName,
    caller: caller
  };
  var configChain = (0, _configChain.buildRootChain)(args, context);
  if (!configChain) return null;
  var options = {};
  configChain.options.forEach(function (opts) {
    (0, _util.mergeOptions)(options, opts);
  });
  options.babelrc = false;
  options.configFile = false;
  options.passPerPreset = false;
  options.envName = context.envName;
  options.cwd = context.cwd;
  options.root = context.root;
  options.filename = typeof context.filename === "string" ? context.filename : undefined;
  options.plugins = configChain.plugins.map(function (descriptor) {
    return (0, _item.createItemFromDescriptor)(descriptor);
  });
  options.presets = configChain.presets.map(function (descriptor) {
    return (0, _item.createItemFromDescriptor)(descriptor);
  });
  return {
    options: options,
    context: context,
    ignore: configChain.ignore,
    babelrc: configChain.babelrc,
    config: configChain.config
  };
}

function loadPartialConfig(inputOpts) {
  var result = loadPrivatePartialConfig(inputOpts);
  if (!result) return null;
  var options = result.options,
      babelrc = result.babelrc,
      ignore = result.ignore,
      config = result.config;

  (options.plugins || []).forEach(function (item) {
    if (item.value instanceof _plugin.default) {
      throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
    }
  });
  return new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined);
}

var PartialConfig = function () {
  function PartialConfig(options, babelrc, ignore, config) {
    _classCallCheck(this, PartialConfig);

    this.options = options;
    this.babelignore = ignore;
    this.babelrc = babelrc;
    this.config = config;
    Object.freeze(this);
  }

  _createClass(PartialConfig, [{
    key: "hasFilesystemConfig",
    value: function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    }
  }]);

  return PartialConfig;
}();

Object.freeze(PartialConfig.prototype);
//# sourceMappingURL=partial.js.map